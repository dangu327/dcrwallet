/*
 * Copyright (c) 2013-2015 The btcsuite developers
 * Copyright (c) 2015 The Decred developers
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

package wallet

import (
	"fmt"
	"sync"

	"github.com/decred/dcrutil"
	"github.com/decred/dcrwallet/waddrmgr"
)

// addressPoolBuffer is the number of addresses to fetch when the address pool
// runs out of new addresses to use.
const addressPoolBuffer = 20

// addressPool is a cache of addresses to use that are generated by the
// address manager. It is safe than directly calling the address manager
// because doing that will increment the cursor of the extended key even
// if the created transaction errors out in some way.
type addressPool struct {
	// Represent addresses as strings because the address interface
	// doesn't have any good way to make comparisons.
	addresses []string
	cursor    int
	account   uint32
	branch    uint32
	index     uint32
	started   bool
	mutex     sync.Mutex
	wallet    *Wallet
}

// newAddressPool creates a new address pool for the wallet default account.
func newAddressPool() *addressPool {
	return &addressPool{
		started: false,
	}
}

// addressPools is a pair of address pools for the two used branches for a
// single account.
type addressPools struct {
	internal *addressPool
	external *addressPool
}

// newAddressPools creates a pair of address pools as an addressPools struct. It
// also initializes the address pools to the passed indexes.
func newAddressPools(account uint32, intIdx, extIdx uint32,
	w *Wallet) (*addressPools, error) {
	a := &addressPools{
		internal: newAddressPool(),
		external: newAddressPool(),
	}
	err := a.internal.initialize(account, waddrmgr.InternalBranch, intIdx, w)
	if err != nil {
		return nil, err
	}
	err = a.external.initialize(account, waddrmgr.ExternalBranch, intIdx, w)
	if err != nil {
		return nil, err
	}

	return a, nil
}

// initialize initializes an address pool for the passed account and branch
// to the address index given.
func (a *addressPool) initialize(account uint32, branch uint32, index uint32,
	w *Wallet) error {
	a.mutex.Lock()
	defer a.mutex.Unlock()

	// Do not reinitialize an address pool that was already started.
	// This can happen if the RPC client dies due to a disconnect
	// from the daemon.
	if a.started {
		return nil
	}

	// 0 and 1 refer to the external and internal branches of the wallet.
	// Other branches are so far unused.
	if branch > waddrmgr.InternalBranch {
		return fmt.Errorf("unknown branch %v given when attempting to "+
			"initialize address pool for account %v", branch, account)
	}

	a.addresses = make([]string, 0)
	a.wallet = w
	a.account = account
	a.branch = branch
	a.index = index

	log.Debugf("Address pool for account %v initialized to next "+
		"addr index %v on branch %v", account, a.index, branch)

	a.cursor = 0
	a.started = true

	return nil
}

// GetNewAddress must be run as many times as necessary with the address pool
// mutex locked. Each time, it returns a single new address while adding that
// address to the toDelete map. If the address pool runs out of addresses, it
// generates more from the address manager.
//
// This function MUST be called with the address pool mutex held and batch
// finish or rollback must be called after.
func (a *addressPool) GetNewAddress() (dcrutil.Address, error) {
	if !a.started {
		return nil, fmt.Errorf("failed to GetNewAddress; pool not started")
	}

	chainClient, err := a.wallet.requireChainClient()
	if err != nil {
		return nil, err
	}

	// Replenish the pool if we're at the last address.
	if a.cursor == len(a.addresses)-1 || len(a.addresses) == 0 {
		var nextAddrFunc func(uint32, uint32) ([]waddrmgr.ManagedAddress, error)
		switch a.branch {
		case waddrmgr.InternalBranch:
			nextAddrFunc = a.wallet.Manager.NextInternalAddresses
		case waddrmgr.ExternalBranch:
			nextAddrFunc = a.wallet.Manager.NextExternalAddresses
		default:
			return nil, fmt.Errorf("unknown default account branch %v", a.branch)
		}

		addrs, err :=
			nextAddrFunc(a.account, addressPoolBuffer)
		if err != nil {
			return nil, err
		}

		for _, addr := range addrs {
			a.addresses = append(a.addresses, addr.Address().EncodeAddress())
		}
	}

	// As these are all encoded addresses, we should never throw an error
	// converting back.
	curAddressStr := a.addresses[a.cursor]
	curAddress, _ := dcrutil.DecodeAddress(curAddressStr, a.wallet.chainParams)
	log.Debugf("Get new address for branch %v returned %s (idx %v) from "+
		"the address pool", a.branch, curAddressStr, a.index)

	a.cursor++
	a.index++

	// Add the address to the notifications watcher.
	addrs := make([]dcrutil.Address, 1)
	addrs[0] = curAddress
	if err := chainClient.NotifyReceived(addrs); err != nil {
		return nil, err
	}

	return curAddress, nil
}

// BatchFinish must be run after every successful series of usages of
// GetNewAddress to purge the addresses from the unused map.
func (a *addressPool) BatchFinish() {
	log.Debugf("Closing address batch for pool branch %v, next index %v",
		a.branch, a.index+1)

	isInternal := a.branch == waddrmgr.InternalBranch
	err := a.wallet.Manager.StoreNextToUseAddress(isInternal, a.account,
		a.index)
	if err != nil {
		log.Errorf("Failed to store next to use address idx for "+
			"pool branch %v, account %v in the manager on batch "+
			"finish: %v", a.branch, a.account, err.Error())
	}

	// We used all the addresses, so we need to pull new addresses
	// on the next call of this function.
	if a.cursor >= len(a.addresses) {
		a.addresses = nil
		a.cursor = 0
		return
	}

	a.addresses = a.addresses[a.cursor:len(a.addresses)]
	a.cursor = 0
}

// BatchRollback must be run after every unsuccessful series of usages
// of GetNewAddress to restore the cursor to the original position in
// the slice, thus marking all addresses unused again.
func (a *addressPool) BatchRollback() {
	a.index -= uint32(a.cursor)
	a.cursor = 0
}

// Close writes the next to use index for the address pool to disk, then sets
// the address pool as closed.
func (a *addressPool) Close() error {
	a.mutex.Lock()
	defer a.mutex.Unlock()

	if !a.started {
		return fmt.Errorf("attempted to close uninitialized address pool")
	}

	isInternal := a.branch == waddrmgr.InternalBranch
	err := a.wallet.Manager.StoreNextToUseAddress(isInternal, a.account,
		a.index)
	if err != nil {
		return fmt.Errorf("Failed to store next to use address idx for "+
			"pool branch %v, account %v in the manager on address "+
			"pool close: %v", a.branch, a.account, err.Error())
	}

	a.started = false
	return nil
}

// CloseAddressPools grabs one last new address for both internal and external
// acounts. Then it inserts them into the address manager database, so that
// the address manager can be used upon startup to restore the cursor position
// in the address pool.
func (w *Wallet) CloseAddressPools() {
	for _, addressPools := range w.addrPools {
		if addressPools.internal == nil {
			return
		}
		if addressPools.external == nil {
			return
		}
		if !addressPools.internal.started || !addressPools.external.started {
			return
		}

		err := addressPools.internal.Close()
		if err != nil {
			log.Errorf("failed to close default acct internal addr pool: %v",
				err)
		}
		err = addressPools.external.Close()
		if err != nil {
			log.Errorf("failed to close default acct external addr pool: %v",
				err)
		}

		delete(w.addrPools, addressPools.internal.account)
	}

	return
}

// CheckAddressPoolsInitialized checks to make sure an address pool exists
// that that one can safely access functions and internal memory such as
// mutexes.
func (w *Wallet) CheckAddressPoolsInitialized(account uint32) error {
	if w.addrPools[account] == nil {
		return fmt.Errorf("Address pools for account %v "+
			"are undeclared", account)
	}
	if w.addrPools[account].external == nil {
		return fmt.Errorf("External address pool for "+
			"account %v is undeclared", account)
	}
	if w.addrPools[account].internal == nil {
		return fmt.Errorf("Internal address pool for "+
			"account %v is undeclared", account)
	}
	if !w.addrPools[account].external.started {
		return fmt.Errorf("External address pool for the "+
			"account %v is uninitialized", account)
	}
	if !w.addrPools[account].internal.started {
		return fmt.Errorf("Internal address pool for the "+
			"account %v is uninitialized", account)
	}

	return nil
}

// GetNewAddressExternal is the exported function that gets a new external address
// for the default account from the external address mempool.
func (w *Wallet) GetNewAddressExternal() (dcrutil.Address, error) {
	err := w.CheckAddressPoolsInitialized(waddrmgr.DefaultAccountNum)
	if err != nil {
		return nil, err
	}

	w.addrPools[waddrmgr.DefaultAccountNum].external.mutex.Lock()
	defer w.addrPools[waddrmgr.DefaultAccountNum].external.mutex.Unlock()
	address, err :=
		w.addrPools[waddrmgr.DefaultAccountNum].external.GetNewAddress()
	if err == nil {
		w.addrPools[waddrmgr.DefaultAccountNum].external.BatchFinish()
	}
	return address, err
}

// GetNewAddressInternal is the exported function that gets a new internal address
// for the default account from the internal address mempool.
func (w *Wallet) GetNewAddressInternal() (dcrutil.Address, error) {
	err := w.CheckAddressPoolsInitialized(waddrmgr.DefaultAccountNum)
	if err != nil {
		return nil, err
	}

	w.addrPools[waddrmgr.DefaultAccountNum].internal.mutex.Lock()
	defer w.addrPools[waddrmgr.DefaultAccountNum].internal.mutex.Unlock()
	address, err :=
		w.addrPools[waddrmgr.DefaultAccountNum].internal.GetNewAddress()
	if err == nil {
		w.addrPools[waddrmgr.DefaultAccountNum].internal.BatchFinish()
	}
	return address, err
}

// NewAddress returns the next external chained address for a wallet given some
// account.
func (w *Wallet) NewAddress(account uint32) (dcrutil.Address, error) {
	err := w.CheckAddressPoolsInitialized(account)
	if err != nil {
		return nil, err
	}

	// Get next address from wallet.
	addr, err := w.addrPools[account].external.GetNewAddress()
	if err != nil {
		return nil, err
	}

	// Request updates from dcrd for new transactions sent to this address.
	utilAddrs := []dcrutil.Address{addr}

	w.chainClientLock.Lock()
	chainClient := w.chainClient
	w.chainClientLock.Unlock()
	if chainClient != nil {
		err := chainClient.NotifyReceived(utilAddrs)
		if err != nil {
			return nil, err
		}
	}

	props, err := w.Manager.AccountProperties(account)
	if err != nil {
		log.Errorf("Cannot fetch account properties for notification "+
			"after deriving next external address: %v", err)
	} else {
		w.NtfnServer.notifyAccountProperties(props)
	}

	return addr, nil
}

// NewChangeAddress returns a new change address for a wallet.
func (w *Wallet) NewChangeAddress(account uint32) (dcrutil.Address, error) {
	err := w.CheckAddressPoolsInitialized(account)
	if err != nil {
		return nil, err
	}

	// Get next chained change address from wallet for account.
	addr, err := w.addrPools[account].internal.GetNewAddress()
	if err != nil {
		return nil, err
	}

	// Request updates from dcrd for new transactions sent to this address.
	utilAddrs := []dcrutil.Address{addr}

	chainClient, err := w.requireChainClient()
	if err == nil {
		err = chainClient.NotifyReceived(utilAddrs)
		if err != nil {
			return nil, err
		}
	}

	return utilAddrs[0], nil
}

// ReusedAddress returns an address that is reused from the external
// branch of the wallet, to cut down on new address usage for wallets.
// Should be used judiciously.
func (w *Wallet) ReusedAddress() (dcrutil.Address, error) {
	addr, err := w.Manager.AddressDerivedFromDbAcct(0,
		waddrmgr.DefaultAccountNum, waddrmgr.ExternalBranch)
	if err != nil {
		return nil, err
	}

	return addr, err
}
